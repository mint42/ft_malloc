srcs/find_header.c:	cur = info->tpages;
srcs/find_header.c:		if ((uintptr_t)ptr >= (uintptr_t)cur + info->tny_pg_offset && (uintptr_t)ptr < (uintptr_t)cur + info->pagesize && ((uintptr_t)ptr - ((uintptr_t)cur + info->tny_pg_offset)) % (info->ts_alheadr_siz + TNY_ALLOC_SIZE) >= info->ts_alheadr_siz)
srcs/find_header.c:			header = (struct s_tsAllocHeader *)((uintptr_t)cur + info->tny_pg_offset + ((info->ts_alheadr_siz + TNY_ALLOC_SIZE) *
srcs/find_header.c:			(((uintptr_t)ptr - ((uintptr_t)cur + info->tny_pg_offset)) / (info->ts_alheadr_siz + TNY_ALLOC_SIZE))));
srcs/find_header.c:			//return ((!header->free) ? header : 0);
srcs/find_header.c:		cur = cur->next_page;
srcs/find_header.c:	cur = info->spages;
srcs/find_header.c:		if ((uintptr_t)ptr >= (uintptr_t)cur + info->sml_pg_offset && (uintptr_t)ptr < (uintptr_t)cur + info->pagesize && ((uintptr_t)ptr - ((uintptr_t)cur + info->sml_pg_offset)) % (info->ts_alheadr_siz + SML_ALLOC_SIZE) >= info->ts_alheadr_siz)
srcs/find_header.c:			header = (struct s_tsAllocHeader *)((uintptr_t)cur + info->tny_pg_offset + ((info->ts_alheadr_siz + TNY_ALLOC_SIZE) *
srcs/find_header.c:			(((uintptr_t)ptr - ((uintptr_t)cur + info->tny_pg_offset)) / (info->ts_alheadr_siz + TNY_ALLOC_SIZE))));
srcs/find_header.c:			//return ((!header->free) ? header : 0);
srcs/find_header.c:		cur = cur->next_page;
srcs/find_header.c:	cur = info->lallocs;
srcs/find_header.c:		if ((uintptr_t)ptr >= (uintptr_t)cur + info->lrg_alheadr_siz && (uintptr_t)ptr <= (uintptr_t)cur + cur->size)
srcs/find_header.c:		cur = cur->next_alloc;
Binary file srcs/find_header.o matches
srcs/free.c:	page_header = (struct s_tsPageHeader *)((uintptr_t)header - ((uintptr_t)header % info->pagesize));
srcs/free.c:	if (page_header->nallocs == 1 && info->ntpages > NPAGES_OVERHEAD)
srcs/free.c:		munmap(page_header, info->pagesize);
srcs/free.c:		((struct s_tsAllocHeader *)header)->free = 1;
srcs/free.c:		((struct s_tsAllocHeader *)header)->used = 0;
srcs/free.c:		((struct s_tsAllocHeader *)header)->next_free = 0;
srcs/free.c:		--page_header->nallocs;
srcs/free.c:		info->free_tallocs_tail->next_free = header;
srcs/free.c:		info->free_tallocs_tail = info->free_tallocs_tail->next_free;
srcs/free.c:	page_header = (struct s_tsPageHeader *)((uintptr_t)header - ((uintptr_t)header % info->pagesize));
srcs/free.c:	if (page_header->nallocs == 1 && info->nspages > NPAGES_OVERHEAD)
srcs/free.c:		munmap(page_header, info->pagesize);
srcs/free.c:		((struct s_tsAllocHeader *)header)->free = 1;
srcs/free.c:		((struct s_tsAllocHeader *)header)->used = 0;
srcs/free.c:		((struct s_tsAllocHeader *)header)->next_free = 0;
srcs/free.c:		--page_header->nallocs;
srcs/free.c:		info->free_sallocs_tail->next_free = header;
srcs/free.c:		info->free_sallocs_tail = info->free_sallocs_tail->next_free;
srcs/free.c:	prev = ((struct s_lAllocHeader *)(header))->prev_alloc;
srcs/free.c:		info->lallocs = info->lallocs->next_alloc;
srcs/free.c:		info->lallocs->prev_alloc = 0;
srcs/free.c:		prev->next_alloc = ((struct s_lAllocHeader *)(header))->next_alloc;
srcs/free.c:	munmap(header, ((struct s_lAllocHeader *)(header))->size);
Binary file srcs/free.o matches
srcs/global_struct.c:	info->pagesize = getpagesize();
srcs/global_struct.c:	info->lrg_alheadr_siz = sizeof(struct s_lAllocHeader);
srcs/global_struct.c:	info->ts_alheadr_siz = sizeof(struct s_tsAllocHeader);
srcs/global_struct.c:	info->ts_pgheadr_siz = sizeof(struct s_tsPageHeader);
srcs/global_struct.c:	info->tny_pg_pad = ((info->pagesize - info->ts_pgheadr_siz) % (info->ts_alheadr_siz + TNY_ALLOC_SIZE));
srcs/global_struct.c:	info->sml_pg_pad = ((info->pagesize - info->ts_pgheadr_siz) % (info->ts_alheadr_siz + SML_ALLOC_SIZE));
srcs/global_struct.c:	info->tny_pg_offset = (info->ts_pgheadr_siz + info->tny_pg_pad);
srcs/global_struct.c:	info->sml_pg_offset = (info->ts_pgheadr_siz + info->sml_pg_pad);
srcs/global_struct.c:	info->tny_pg_space = (info->pagesize - info->tny_pg_offset);
srcs/global_struct.c:	info->sml_pg_space = (info->pagesize - info->sml_pg_offset);
srcs/global_struct.c:	info->n_tny_alocs_per_pg = (info->tny_pg_space / (info->ts_alheadr_siz + TNY_ALLOC_SIZE));
srcs/global_struct.c:	info->n_sml_alocs_per_pg = (info->sml_pg_space / (info->ts_alheadr_siz + SML_ALLOC_SIZE));
srcs/global_struct.c:	page = mmap(0, getpagesize(), PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
srcs/global_struct.c:	info->lallocs = 0;
srcs/global_struct.c:	info->ntpages = 0;
srcs/global_struct.c:	info->nspages = 0;
Binary file srcs/global_struct.o matches
srcs/malloc.c:		if (!info->free_tallocs)
srcs/malloc.c:		ptr = (void *)((uintptr_t)info->free_tallocs + info->ts_alheadr_siz);
srcs/malloc.c:		info->free_tallocs = info->free_tallocs->next_free;
srcs/malloc.c://		((struct s_tsAllocHeader *)(ptr))->free = 0;
srcs/malloc.c:		((struct s_tsAllocHeader *)(ptr))->used = size;
srcs/malloc.c:		if (!info->free_sallocs)
srcs/malloc.c:		ptr = (void *)((uintptr_t)info->free_sallocs + info->ts_alheadr_siz);
srcs/malloc.c:		info->free_sallocs = info->free_sallocs->next_free;
srcs/malloc.c://		((struct s_tsAllocHeader *)(ptr))->free = 0;
srcs/malloc.c:		((struct s_tsAllocHeader *)(ptr))->used = size;
srcs/malloc.c:		ptr = (void *)((uintptr_t)info->lallocs + info->lrg_alheadr_siz);
Binary file srcs/malloc.o matches
srcs/mem.c:		size = size - sizeoflong;
srcs/mem.c:		--size;
srcs/mem.c:		size = size - sizeoflong;
srcs/mem.c:		--size;
Binary file srcs/mem.o matches
srcs/new_pages.c:	size = ((used_size / info->pagesize) + 1) * info->pagesize;
srcs/new_pages.c:	new_alloc = mmap(0, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
srcs/new_pages.c:	new_header->size = size;
srcs/new_pages.c:	new_header->used = used_size;
srcs/new_pages.c:	if (!info->lallocs)
srcs/new_pages.c:		new_header->prev_alloc = 0;
srcs/new_pages.c:		new_header->next_alloc = 0;
srcs/new_pages.c:		info->lallocs->prev_alloc = new_header;
srcs/new_pages.c:		new_header->next_alloc = info->lallocs;
srcs/new_pages.c:	info->lallocs = new_header;
srcs/new_pages.c:	if (!info->tpages)
srcs/new_pages.c:		info->tpages = (struct s_tsPageHeader *)new_page;
srcs/new_pages.c:		info->tpages_tail->next_page = (struct s_tsPageHeader *)new_page;
srcs/new_pages.c:	new_header = (struct s_tsAllocHeader *)((uintptr_t)new_page + info->tny_pg_offset);
srcs/new_pages.c:	if (!info->free_tallocs)
srcs/new_pages.c:		info->free_tallocs = new_header;
srcs/new_pages.c:		info->free_tallocs_tail->next_free = new_header;
srcs/new_pages.c:	new_header->free = 1;
srcs/new_pages.c:	new_header->used = 0;
srcs/new_pages.c:	new_header->next_free = 0;
srcs/new_pages.c:	while (i < info->n_tny_alocs_per_pg)
srcs/new_pages.c:		new_header->next_free = (struct s_tsAllocHeader *)((uintptr_t)new_header + info->ts_alheadr_siz + TNY_ALLOC_SIZE);
srcs/new_pages.c:		new_header = new_header->next_free;
srcs/new_pages.c:		new_header->free = 1;
srcs/new_pages.c:		new_header->used = 0;
srcs/new_pages.c:		new_header->next_free = 0;
srcs/new_pages.c:	info->tpages_tail = (struct s_tsPageHeader *)new_page;
srcs/new_pages.c:	info->free_tallocs_tail = new_header;
srcs/new_pages.c:	++info->ntpages;
srcs/new_pages.c:	if (!info->spages)
srcs/new_pages.c:		info->spages = (struct s_tsPageHeader *)new_page;
srcs/new_pages.c:		info->spages_tail->next_page = (struct s_tsPageHeader *)new_page;
srcs/new_pages.c:	new_header = (struct s_tsAllocHeader *)((uintptr_t)new_page + info->sml_pg_offset);
srcs/new_pages.c:	if (!info->free_sallocs)
srcs/new_pages.c:		info->free_sallocs = new_header;
srcs/new_pages.c:		info->free_sallocs_tail->next_free = new_header;
srcs/new_pages.c:	new_header->free = 1;
srcs/new_pages.c:	new_header->used = 0;
srcs/new_pages.c:	new_header->next_free = 0;
srcs/new_pages.c:	while (i < info->n_sml_alocs_per_pg)
srcs/new_pages.c:		new_header->next_free = (struct s_tsAllocHeader *)((uintptr_t)new_header + info->ts_alheadr_siz + SML_ALLOC_SIZE);
srcs/new_pages.c:		new_header = new_header->next_free;
srcs/new_pages.c:		new_header->free = 1;
srcs/new_pages.c:		new_header->used = 0;
srcs/new_pages.c:		new_header->next_free = 0;
srcs/new_pages.c:	info->spages_tail = (struct s_tsPageHeader *)new_page;
srcs/new_pages.c:	info->free_sallocs_tail = new_header;
srcs/new_pages.c:	++info->nspages;
srcs/new_pages.c:	new_page = mmap(0, info->pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
srcs/new_pages.c:	new_pheader->nallocs = 0;
srcs/new_pages.c:	new_pheader->next_page = 0;
Binary file srcs/new_pages.o matches
srcs/print.c:	printf("info->ntpages               %zu\n", info->ntpages);
srcs/print.c:	printf("info->nspages               %zu\n", info->nspages);
srcs/print.c:	printf("info->pagesize              %zu\n", info->pagesize);
srcs/print.c:	printf("info->lrg_alheadr_siz       %zu\n", info->lrg_alheadr_siz);
srcs/print.c:	printf("info->ts_alheadr_siz        %zu\n", info->ts_alheadr_siz);
srcs/print.c:	printf("info->ts_pgheadr_siz        %zu\n", info->ts_pgheadr_siz);
srcs/print.c:	printf("info->tny_pg_pad            %zu\n", info->tny_pg_pad);
srcs/print.c:	printf("info->sml_pg_pad            %zu\n", info->sml_pg_pad);
srcs/print.c:	printf("info->tny_pg_offset         %zu\n", info->tny_pg_offset);
srcs/print.c:	printf("info->sml_pg_offset         %zu\n", info->sml_pg_offset);
srcs/print.c:	printf("info->tny_pg_space          %zu\n", info->tny_pg_space);
srcs/print.c:	printf("info->sml_pg_space          %zu\n", info->sml_pg_space);
srcs/print.c:	printf("info->n_tny_alocs_per_pg    %zu\n", info->n_tny_alocs_per_pg);
srcs/print.c:	printf("info->n_sml_alocs_per_pg    %zu\n", info->n_sml_alocs_per_pg);
Binary file srcs/print.o matches
srcs/realloc.c:		((struct s_tsAllocHeader *)(header))->used = new_size;
srcs/realloc.c:	else if (zone == LARGE && new_size <= ((struct s_lAllocHeader *)(header))->size)
srcs/realloc.c:		((struct s_lAllocHeader *)(header))->used = new_size;
srcs/realloc.c:			old_size = ((struct s_tsAllocHeader *)(header))->used;
srcs/realloc.c:			old_size = ((struct s_lAllocHeader *)(header))->used;
Binary file srcs/realloc.o matches
